knitr::opts_chunk$set(echo = TRUE)
# Loading packages and reading data
library(pwr)
library(effectsize)
library(broom)
library(broom)
library(afex)
library(performance)
library(tidyverse)
james_data <- read_csv("James_2015.csv") %>%
mutate(PID = row_number(),
Condition = as.factor(Condition)) %>%
select(PID,
Condition,
intrusions = Days_One_to_Seven_Image_Based_Intrusions_in_Intrusion_Diary)
PID
print(PID)
james_data <- read_csv("James_2015.csv") %>%
mutate(PID = row_number(),
Condition = as.factor(Condition)) %>%
select(PID,
Condition,
intrusions = Days_One_to_Seven_Image_Based_Intrusions_in_Intrusion_Diary)
str(james_data)
View(james_data)
View(james_data)
head(james_data)
#Create a violin-boxplot with the number of intrusive memories on the y-axis and condition on the x-axis (See Chapter 7 if you need a reminder).
#Change the labels on the x-axis to something more informative for the condition names.
james_data %>%
group_by(Condition) %>%
summarise(mean = round(mean(intrusions), 2),
sd = round(sd(intrusions), 2),
se = round(sd/sqrt(length(intrusions)), 2))
james_data %>%
ggplot(aes(x = Condition, y = intrusions))+
geom_violin()+
#geom_boxplot(width = .2) +
scale_y_continuous(name = "Number of Intrusions") +
scale_x_discrete(labels = c("Control", "Reactivation + Tetris", "Tetris", "Reactivation")) +
theme_classic()
#Create a violin-boxplot with the number of intrusive memories on the y-axis and condition on the x-axis (See Chapter 7 if you need a reminder).
#Change the labels on the x-axis to something more informative for the condition names.
james_data %>%
group_by(Condition) %>%
summarise(mean = round(mean(intrusions), 2),
sd = round(sd(intrusions), 2),
se = round(sd/sqrt(length(intrusions)), 2))
james_data %>%
ggplot(aes(x = Condition, y = intrusions))+
geom_violin()+
geom_boxplot(width = .2) +
scale_y_continuous(name = "Number of Intrusions") +
scale_x_discrete(labels = c("Control", "Reactivation + Tetris", "Tetris", "Reactivation")) +
theme_classic()
james_data %>%
ggplot(aes(x = Condition, y = intrusions))+
geom_violin()+
geom_boxplot(width = .2) +
geom_jitter +
scale_y_continuous(name = "Number of Intrusions") +
scale_x_discrete(labels = c("Control", "Reactivation + Tetris", "Tetris", "Reactivation")) +
theme_classic()
james_data %>%
ggplot(aes(x = Condition, y = intrusions))+
geom_violin()+
geom_boxplot(width = .2) +
geom_jitter() +
scale_y_continuous(name = "Number of Intrusions") +
scale_x_discrete(labels = c("Control", "Reactivation + Tetris", "Tetris", "Reactivation")) +
theme_classic()
james_data %>%
ggplot(aes(x = Condition, y = intrusions))+
geom_violin()+
geom_boxplot(width = .2) +
geom_jitter(width = .2) +
scale_y_continuous(name = "Number of Intrusions") +
scale_x_discrete(labels = c("Control", "Reactivation + Tetris", "Tetris", "Reactivation")) +
theme_classic()
#Create a violin-boxplot with the number of intrusive memories on the y-axis and condition on the x-axis (See Chapter 7 if you need a reminder).
#Change the labels on the x-axis to something more informative for the condition names.
james_data %>%
group_by(Condition) %>%
summarise(mean = round(mean(intrusions), 2),
sd = round(sd(intrusions), 2),
se = round(sd/sqrt(length(intrusions)), 2))
james_data %>%
ggplot(aes(x = Condition, y = intrusions))+
geom_violin()+
geom_boxplot(width = .2) +
geom_jitter(width = .2) +
scale_y_continuous(name = "Number of Intrusions") +
scale_x_discrete(labels = c("Control", "Reactivation + Tetris", "Tetris", "Reactivation")) +
theme_classic()
mod <- aov(Condition~Intrusions)
mod <- aov(Condition~Intrusions, data=james_data)
mod <- aov(Condition~intrusions, data=james_data)
mod <- aov(intrusions~Condition, data=james_data)
summary(mod)
?aov
mod <- aov(intrusions~Condition, data=james_data)
summary(mod)
#Your answer here
plot(mod, which=1)
plot(mod, which=1)plot(mod, which=1)
#Your answer here
plot(mod, which=1)
plot(mod, which=2)
plot(mod, which=3)
plot(mod, which=4)
plot(mod, which=5)
plot(mod, which=6)
check_model(mod)
library(performance)
# Loading packages and reading data
install.packages('performace')
library(performance)
# Loading packages and reading data
install.packages('performance')
plot(mod, which=2)
library(performance)
#Your answer here
plot(mod, which=1)
plot(mod, which=3)
plot(mod, which=4)
plot(mod, which=5)
plot(mod, which=6)
plot(mod, which=5)
check_model(mod)
